#include <fstream>
#include <array>
#include <bitset>

typedef struct metadata {
	char* signature = (char*)malloc(sizeof(char)*3);
	int file_size;
	int array_offset;
	int dib_size;
	int bmp_width;
	int bmp_height;
	int image_size;
	int bpp;

	~metadata(){free(signature);}
} metadata;

typedef struct pixel_array {
	int width;
	int height;
	int pixel_width;
	char* pixels;
	~pixel_array(){free(pixels);}
} pixel_array;

class DwarfCanvasReader {
private:
	std::ifstream input_bmp;
	const int BMP_HEADER_LENGTH = 14;
	const int DIB_HEADER_LENGTH = 40;
	metadata file_info;
	pixel_array pa;

public:
	DwarfCanvasReader(std::string input, int argc)
	: input_bmp(input, std::ios::binary)
	{

		input_bmp.seekg (0, input_bmp.end);
		if(input_bmp.tellg() < (BMP_HEADER_LENGTH + DIB_HEADER_LENGTH))
			throw std::logic_error("File error : input file is too small to be a valid bitmap image, or was not opened");
		input_bmp.seekg (0, input_bmp.beg);

		char _meta[BMP_HEADER_LENGTH + DIB_HEADER_LENGTH];
		input_bmp.read(_meta, BMP_HEADER_LENGTH + DIB_HEADER_LENGTH);
		file_info.signature[0] = _meta[0];
		file_info.signature[1] = _meta[1];
		file_info.signature[2] = '\0';
		file_info.file_size = (int)(_meta[5] + _meta[4] + _meta[3] + _meta[2]);
		file_info.array_offset = (int)(_meta[10] + _meta[11] + _meta[12] + _meta[13]);
		file_info.dib_size = (int)(_meta[14] + _meta[15] + _meta[16] + _meta[17]);
		file_info.bmp_width = (int)(_meta[18] + _meta[19] + _meta[20] + _meta[21]);
		file_info.bmp_height = (int)(_meta[22] + _meta[23] + _meta[24] + _meta[25]);
		file_info.bpp = (int)(_meta[28] + _meta[29]);
		file_info.image_size = (int)(_meta[34] + _meta[35] + _meta[36] + _meta[37]);

		pa.width = file_info.bmp_width;
		pa.height = file_info.bmp_height;
		pa.pixel_width = file_info.bpp/8;
		input_bmp.seekg(file_info.array_offset, input_bmp.beg);
		pa.pixels = (char*)malloc(sizeof(char)*file_info.image_size);
		input_bmp.read(pa.pixels, file_info.image_size);
		atoi(pa.pixels);
	}

	metadata& metadata() {return file_info;}
	pixel_array& raw_image() {return pa;}
};

class DwarfCanvasFormatter {
private:
	pixel_array& pa;
	std::stringstream color_tags;
public:
	DwarfCanvasFormatter(pixel_array& _pa)
	: pa(_pa)
	{
		int name_iterator = 0;
		const char* color_names[48]
			= {"[BLACK_R:","[BLACK_G:","[BLACK_B:","[BLUE_R:","[BLUE_G:","[BLUE_B:","[GREEN_R:","[GREEN_G:","[GREEN_B:","[CYAN_R:","[CYAN_G:","[CYAN_B:","[RED_R:","[RED_G:","[RED_B:","[MAGENTA_R:","[MAGENTA_G:","[MAGENTA_B:","[BROWN_R:","[BROWN_G:","[BROWN_B:","[LGRAY_R:","[LGRAY_G:","[LGRAY_B:","[DGRAY_R:","[DGRAY_G:","[DGRAY_B:","[LBLUE_R:","[LBLUE_G:","[LBLUE_B:","[LGREEN_R:","[LGREEN_G:","[LGREEN_B:","[LCYAN_R:","[LCYAN_G:","[LCYAN_B:","[LRED_R:","[LRED_G:","[LRED_B:","[LMAGENTA_R:","[LMAGENTA_G:","[LMAGENTA_B:","[YELLOW_R:","[YELLOW_G:","[YELLOW_B:","[WHITE_R:","[WHITE_G:","[WHITE_B:"};
		color_tags << "Color raws generated by Dwarf Canvas\n\n";
		for(int pixel_iter = 8*pa.pixel_width; pixel_iter < pa.pixel_width*16; pixel_iter+=(pa.pixel_width)) {
			color_tags << color_names[name_iterator] << ((std::bitset<8>)pa.pixels[pixel_iter+2]).to_ulong() << "]\n";
			color_tags << color_names[name_iterator+1] << ((std::bitset<8>)pa.pixels[pixel_iter+1]).to_ulong() << "]\n";
			color_tags << color_names[name_iterator+2] << ((std::bitset<8>)pa.pixels[pixel_iter]).to_ulong() << "]\n";
			 name_iterator+=3;
		}
		for(int pixel_iter = 0; pixel_iter < pa.pixel_width*8; pixel_iter+=(pa.pixel_width)) {
			color_tags << color_names[name_iterator] << ((std::bitset<8>)pa.pixels[pixel_iter+2]).to_ulong() << "]\n";
			color_tags << color_names[name_iterator+1] << ((std::bitset<8>)pa.pixels[pixel_iter+1]).to_ulong() << "]\n";
			color_tags << color_names[name_iterator+2] << ((std::bitset<8>)pa.pixels[pixel_iter]).to_ulong() << "]\n";
			name_iterator+=3;
		}
	}
	pixel_array& raw_image() {return pa;}
	std::stringstream& raw_tags() {return color_tags;}
};

class DwarfCanvasWriter{
public:
	DwarfCanvasWriter(std::string output_file, DwarfCanvasFormatter& _dcf)
	{
		std::ofstream output(output_file);
		output << _dcf.raw_tags().str();
	}
};
